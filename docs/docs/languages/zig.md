---
sidebar_position: 6
---

# Zig

Zig workers are tested with Zig version `0.11.0`. Then, they are loaded by Wasm Workers Server and start processing requests.

## Your first Zig worker

Workers can be implemented via `worker.ServeFunc``.

In this example, the worker will get a request and print all the related information.

1. Create a new Zig project:

    ```bash

    ```

2. Add Wasm Workers Server Zig dependency

    At this point in time Zigs Package manager is not yet available. You will have to clone this repo instead.

    ```
    git clone git@github.com/vmware-labs/wasm-workers-server/
    ```

3. Create a `worker.go` file with the following contents:

    ```c title="worker.zig"
    const std = @import("std");
    const worker = @import("worker");

    fn requestFn(resp: *worker.Response, r: *worker.Request) void {
        _ = r;
        _ = &resp.headers.append("x-generated-by", "wasm-workers-server");
        _ = &resp.writeAll("Hello from Zig ‚ö°Ô∏è!");
    }

    pub fn main() !void {
        worker.ServeFunc(requestFn);
    }
    ```

4. Additionally, you can now go further add all the information from the received `worker.Request`:

    ```c title="worker.zig"
    const std = @import("std");
    const worker = @import("worker");

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const allocator = arena.allocator();

    fn requestFn(resp: *worker.Response, r: *worker.Request) void {
        std.debug.print("Hello from function\n", .{ });

        // // TODO: prepare to read request body and send it back
        std.debug.print("+++ doing payload \n", .{ });

        var payload: []const u8 = "";
        var reqBody = r.data;

        if (reqBody.len == 0) {
            payload = "-";
        } else {
            payload = reqBody;
        }

        const s =
            \\<!DOCTYPE html>
            \\<head>
            \\<title>Wasm Workers Server</title>
            \\<meta name="viewport" content="width=device-width,initial-scale=1">
            \\<meta charset="UTF-8">
            \\<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
    		\\<style>
    		\\body {{ max-width: 1000px; }}
    		\\main {{ margin: 5rem 0; }}
    		\\h1, p {{ text-align: center; }}
    		\\h1 {{ margin-bottom: 2rem; }}
    		\\pre {{ font-size: .9rem; }}
    		\\pre > code {{ padding: 2rem; }}
    		\\p {{ margin-top: 2rem; }}
    		\\</style>
            \\</head>
            \\<body>
            \\<main>
            \\<h1>Hello from Wasm Workers Server üëã</h1>
            \\<pre><code>Replying to {s}
            \\Method: {s}
            \\User Agent: {s}
            \\Payload: {s}</code></pre>
            \\<p>
            \\This page was generated by a Zig‚ö°Ô∏è file running in WebAssembly.
            \\</p>
            \\</main>
            \\</body>
        ;

        var body = std.fmt.allocPrint(allocator, s, .{ r.url.path, r.method, "-", payload }) catch undefined; // add useragent

        _ = &resp.headers.append("x-generated-by", "wasm-workers-server");
        _ = &resp.writeAll(body);
    }

    pub fn main() !void {
        worker.ServeFunc(requestFn);
    }
    ```

5. In this case, you need to compile the project to Wasm ([WASI](https://wasi.dev/)).

    ```bash
    zig build -Dtarget="wasm32-wasi"
    ```

6. Run your worker with `wws`. If you didn't download the `wws` server yet, check our [Getting Started](../get-started/quickstart.md) guide.

    ```bash
    wws .

    ‚öôÔ∏è Loading routes from: .
    üó∫ Detected routes:
    - http://127.0.0.1:8080/worker
    => worker.wasm (name: default)
    üöÄ Start serving requests at http://127.0.0.1:8080
    ```

7. Finally, open <http://127.0.0.1:8080/worker> in your browser.

<!--
## Add a Key / Value store

Wasm Workers allows you to add a Key / Value store to your workers. Read more information about this feature in the [Key / Value store](../features/key-value.md) section.

To add a KV store to your worker, follow these steps:

1. Create a new Go project:

    ```bash
    go mod init worker-kv
    ```

1. Add the Wasm Workers Server Go dependency

    ```
    go get -u github.com/vmware-labs/wasm-workers-server/kits/go/worker@v1.3.0
    ```

1. Create a `worker-kv.go` file with the following contents:

    ```go title="worker-kv.go"
    package main

    import (
	    "net/http"

	    "github.com/vmware-labs/wasm-workers-server/kits/go/worker"
    )

    func main() {
        worker.ServeFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("x-generated-by", "wasm-workers-server")
            w.Write([]byte("Hello wasm!"))
        })
    }
    ```

1. Then, let's read a value from the cache and update it:

    ```go title="worker-kv.go"
    package main

    import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/vmware-labs/wasm-workers-server/kits/go/worker"
    )

    func main() {
        worker.ServeFunc(func(w http.ResponseWriter, r *http.Request) {
            cache, _ := r.Context().Value(worker.CacheKey).(map[string]string)

            var countNum uint32

            if count, ok := cache["counter"]; ok {
                n, _ := strconv.ParseUint(count, 10, 32)
                countNum = uint32(n)
            }

            body := fmt.Sprintf("<!DOCTYPE html>"+
                "<body>"+
                "<h1>Key / Value store in Go</h1>"+
                "<p>Counter: %d</p>"+
                "<p>This page was generated by a Wasm module built from Go.</p>"+
                "</body>", countNum)

            cache["counter"] = fmt.Sprintf("%d", countNum+1)

            w.Header().Set("x-generated-by", "wasm-workers-server")
            w.Write([]byte(body))
        })
    }
    ```

1. Compile the project to Wasm ([WASI](https://wasi.dev/)):

    ```bash
    tinygo build -o worker-kv.wasm -target wasi worker-kv.go
    ```

1. Create a `worker-kv.toml` file with the following content. Note the name of the TOML file must match the name of the worker. In this case we have `worker-kv.wasm` and `worker-kv.toml` in the same folder:

    ```toml title="worker-kv.toml"
    name = "workerkv"
    version = "1"

    [data]
    [data.kv]
    namespace = "workerkv"
    ```

1. Run your worker with `wws`. If you didn't download the `wws` server yet, check our [Getting Started](../get-started/quickstart.md) guide.

    ```bash
    wws .

    ‚öôÔ∏è Loading routes from: .
    üó∫ Detected routes:
    - http://127.0.0.1:8080/worker-kv
    => worker-kv.wasm (name: default)
    üöÄ Start serving requests at http://127.0.0.1:8080
    ```

1. Finally, open <http://127.0.0.1:8080/worker-kv> in your browser.

 -->

## Dynamic routes

<!--
You can define [dynamic routes by adding route parameters to your worker files](../features/dynamic-routes.md) (like `[id].wasm`). To read them in Go, follow these steps:

1. Use the `worker.ParamsKey` context value to read in the passed in parameters:

    ```go title="main.go"
    package main

    import (
        "fmt"
        "net/http"

        "github.com/vmware-labs/wasm-workers-server/kits/go/worker"
    )

    func main() {
        worker.ServeFunc(func(w http.ResponseWriter, r *http.Request) {
            params, _ := r.Context().Value(worker.ParamsKey).(map[string]string)
            ...
        })
    }
    ```

2. Then, you can read the values as follows:

    ```go title="main.go"
    package main

    import (
        "fmt"
        "net/http"

        "github.com/vmware-labs/wasm-workers-server/kits/go/worker"
    )

    func main() {
        worker.ServeFunc(func(w http.ResponseWriter, r *http.Request) {
            params, _ := r.Context().Value(worker.ParamsKey).(map[string]string)
            id := "the value is not available"

            if val, ok := params["id"]; ok {
                id = val
            }

            w.Header().Set("x-generated-by", "wasm-workers-server")
            w.Write([]byte(fmt.Sprintf("Hey! The parameter is: %s", id)))
        })
    }
    ```
-->

## Read environment variables

<!--
Environment variables are configured [via the related TOML configuration file](../features/environment-variables.md). These variables are accessible via `os.Getenv` in your worker. To read them, just use the same name you configured in your TOML file:

```toml title="envs.toml"
name = "envs"
version = "1"

[vars]
MESSAGE = "Hello üëã! This message comes from an environment variable"
```

Now, you can read the `MESSAGE` variable using the [`os.Getenv`](https://pkg.go.dev/os#Getenv) function:

```go title="envs.go"
package main

import (
	"fmt"
	"net/http"
	"os"

	"github.com/vmware-labs/wasm-workers-server/kits/go/worker"
)

func main() {
	worker.ServeFunc(func(w http.ResponseWriter, r *http.Request) {
		body := fmt.Sprintf("The message is: %s", os.Getenv("MESSAGE"))

		w.Header().Set("x-generated-by", "wasm-workers-server")
		w.Write([]byte(body))
	})
}

```

If you prefer, you can configure the environment variable value dynamically by following [these instructions](../features/environment-variables.md#inject-existing-environment-variables).

-->

## Other examples

Find other examples in the [`/examples` directory](https://github.com/vmware-labs/wasm-workers-server/tree/main/examples/) of wasm-workers-server repository.

## Contributors

The Zig kit was originally authored by Christoph Voigt ([@voigt](https://github.com/voigt)).

## Feature compatibility

[Workers' features](../features/all.md) that are available in Zig:

| [K/V Store](../features/key-value.md) | [Environment Variables](../features/environment-variables.md) | [Dynamic Routes](../features/dynamic-routes.md) | [Folders](../features/mount-folders.md) | [HTTP Requests](../features/http-requests.md) |
| --- | --- | --- | --- | --- |
|  ‚úÖ | ‚ùå | ‚úÖ | ‚ùì | ‚ùå |
