#[cfg(test)]
mod test {
    use std::path::PathBuf;
    use std::process::{Child, Command, Stdio};
    use std::{env, io, thread, time};

    #[cfg(not(target_os = "windows"))]
    fn run_debug(example_path: &str) -> io::Result<Child> {
        let path = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());

        // Use release when it's available
        let wws_path = if path.join("target/release/wws").exists() {
            path.join("target/release/wws")
        } else {
            path.join("target/debug/wws")
        };

        println!("Running wws from {}", wws_path.display());

        Command::new(path.join(wws_path))
            .arg(path.join("examples").join(example_path))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
    }

    #[cfg(target_os = "windows")]
    fn run_debug(example_path: &str) -> io::Result<Child> {
        let path = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap());

        // Use release when it's available
        let wws_path = if path.join("target\\release\\wws.exe").exists() {
            path.join("target\\release\\wws.exe")
        } else {
            path.join("target\\debug\\wws.exe")
        };

        println!("Running wws from {}", wws_path.display());

        Command::new(path.join(wws_path))
            .arg(path.join("examples").join(example_path))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
    }

    fn sleep_for(seconds: u64) {
        thread::sleep(time::Duration::from_secs(seconds));
    }

    fn request_body(url: &str) -> Result<String, reqwest::Error> {
        reqwest::blocking::get(url)?.text()
    }

    // Check the examples/js-json works
    fn run_end_to_end_test(example: &str, waiting_seconds: u64, url: &str, expected_text: &str) {
        let mut child = run_debug(example).expect("Failed to execute command");

        sleep_for(waiting_seconds);

        let body = match request_body(url) {
            Ok(body) => body,
            Err(err) => {
                eprintln!("Error getting the body from the request to {url}");
                eprintln!("Error: {}", err);
                String::new()
            }
        };

        println!("Body content: {body}");

        // Test
        assert!(body.contains(expected_text));

        println!("Stopping wws process [{}]", &child.id());
        child.kill().expect("Error stopping wws");
    }

    #[test]
    // Use this approach to run tests sequentially
    fn test_end_to_end() {
        // Allow configuring waiting times. It avoids having long waiting times
        // in development, while making it configurable in the CI
        let global_timeout: Option<u64> = match env::var("E2E_WAITING_TIME") {
            Ok(val) => match val.parse::<u64>() {
                Ok(val) => Some(val),
                Err(_) => None,
            },
            Err(_) => None,
        };

        let tests = [
            (
                "rust-basic",
                global_timeout.unwrap_or(10),
                "http://localhost:8080/basic",
                "This page was generated by a Wasm module built from Rust",
            ),
            (
                "rust-kv",
                global_timeout.unwrap_or(10),
                "http://localhost:8080/kv",
                "Counter: 0",
            ),
            (
                "js-basic",
                global_timeout.unwrap_or(10),
                "http://localhost:8080",
                "This page was generated by a JavaScript file",
            ),
            (
                "js-json",
                global_timeout.unwrap_or(10),
                "http://localhost:8080/handler",
                "This message comes from an environment variable",
            ),
            (
                "js-params",
                global_timeout.unwrap_or(25),
                "http://localhost:8080/thisisatest",
                "thisisatest",
            ),
        ];

        for (example, waiting_seconds, url, expected_text) in tests {
            run_end_to_end_test(example, waiting_seconds, url, expected_text);
        }
    }
}
